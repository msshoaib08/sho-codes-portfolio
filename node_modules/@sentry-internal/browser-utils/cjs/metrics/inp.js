var {
  _optionalChain
} = require('@sentry/utils');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const utils$1 = require('@sentry/utils');
const instrument = require('./instrument.js');
const utils = require('./utils.js');

/**
 * Start tracking INP webvital events.
 */
function startTrackingINP() {
  const performance = utils.getBrowserPerformanceAPI();
  if (performance && utils$1.browserPerformanceTimeOrigin) {
    const inpCallback = _trackINP();

    return () => {
      inpCallback();
    };
  }

  return () => undefined;
}

const INP_ENTRY_MAP = {
  click: 'click',
  pointerdown: 'click',
  pointerup: 'click',
  mousedown: 'click',
  mouseup: 'click',
  touchstart: 'click',
  touchend: 'click',
  mouseover: 'hover',
  mouseout: 'hover',
  mouseenter: 'hover',
  mouseleave: 'hover',
  pointerover: 'hover',
  pointerout: 'hover',
  pointerenter: 'hover',
  pointerleave: 'hover',
  dragstart: 'drag',
  dragend: 'drag',
  drag: 'drag',
  dragenter: 'drag',
  dragleave: 'drag',
  dragover: 'drag',
  drop: 'drag',
  keydown: 'press',
  keyup: 'press',
  keypress: 'press',
  input: 'press',
};

/** Starts tracking the Interaction to Next Paint on the current page. */
function _trackINP() {
  return instrument.addInpInstrumentationHandler(({ metric }) => {
    const client = core.getClient();
    if (!client || metric.value == undefined) {
      return;
    }

    const entry = metric.entries.find(entry => entry.duration === metric.value && INP_ENTRY_MAP[entry.name]);

    if (!entry) {
      return;
    }

    const interactionType = INP_ENTRY_MAP[entry.name];

    const options = client.getOptions();
    /** Build the INP span, create an envelope from the span, and then send the envelope */
    const startTime = utils.msToSec((utils$1.browserPerformanceTimeOrigin ) + entry.startTime);
    const duration = utils.msToSec(metric.value);
    const scope = core.getCurrentScope();
    const activeSpan = core.getActiveSpan();
    const rootSpan = activeSpan ? core.getRootSpan(activeSpan) : undefined;

    const routeName = rootSpan ? core.spanToJSON(rootSpan).description : undefined;
    const user = scope.getUser();

    // We need to get the replay, user, and activeTransaction from the current scope
    // so that we can associate replay id, profile id, and a user display to the span
    const replay = client.getIntegrationByName('Replay');

    const replayId = replay && replay.getReplayId();

    const userDisplay = user !== undefined ? user.email || user.id || user.ip_address : undefined;
    const profileId = _optionalChain([scope, 'access', _ => _.getScopeData, 'call', _2 => _2(), 'access', _3 => _3.contexts, 'optionalAccess', _4 => _4.profile, 'optionalAccess', _5 => _5.profile_id]) ;

    const name = utils$1.htmlTreeAsString(entry.target);
    const attributes = utils$1.dropUndefinedKeys({
      release: options.release,
      environment: options.environment,
      transaction: routeName,
      [core.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: metric.value,
      user: userDisplay || undefined,
      profile_id: profileId || undefined,
      replay_id: replayId || undefined,
    });

    const span = core.startInactiveSpan({
      name,
      op: `ui.interaction.${interactionType}`,
      attributes,
      startTime: startTime,
      experimental: {
        standalone: true,
      },
    });

    span.addEvent('inp', {
      [core.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: 'millisecond',
      [core.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: metric.value,
    });

    span.end(startTime + duration);
  });
}

exports.startTrackingINP = startTrackingINP;
//# sourceMappingURL=inp.js.map
