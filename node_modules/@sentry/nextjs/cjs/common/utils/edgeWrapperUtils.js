Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const utils = require('@sentry/utils');
const responseEnd = require('./responseEnd.js');
const tracingUtils = require('./tracingUtils.js');

/**
 * Wraps a function on the edge runtime with error and performance monitoring.
 */
function withEdgeWrapping(
  handler,
  options,
) {
  return async function ( ...args) {
    return tracingUtils.escapeNextjsTracing(() => {
      const req = args[0];
      return core.withIsolationScope(tracingUtils.commonObjectToIsolationScope(req), isolationScope => {
        let sentryTrace;
        let baggage;

        if (req instanceof Request) {
          sentryTrace = req.headers.get('sentry-trace') || '';
          baggage = req.headers.get('baggage');

          isolationScope.setSDKProcessingMetadata({
            request: utils.winterCGRequestToRequestData(req),
          });
        }

        isolationScope.setTransactionName(options.spanDescription);

        return core.continueTrace(
          {
            sentryTrace,
            baggage,
          },
          () => {
            return core.startSpan(
              {
                name: options.spanDescription,
                op: options.spanOp,
                forceTransaction: true,
                attributes: {
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.withEdgeWrapping',
                },
              },
              async span => {
                const handlerResult = await core.handleCallbackErrors(
                  () => handler.apply(this, args),
                  error => {
                    core.captureException(error, {
                      mechanism: {
                        type: 'instrument',
                        handled: false,
                        data: {
                          function: options.mechanismFunctionName,
                        },
                      },
                    });
                  },
                );

                if (handlerResult instanceof Response) {
                  core.setHttpStatus(span, handlerResult.status);
                } else {
                  span.setStatus({ code: core.SPAN_STATUS_OK });
                }

                return handlerResult;
              },
            ).finally(() => responseEnd.flushQueue());
          },
        );
      });
    });
  };
}

exports.withEdgeWrapping = withEdgeWrapping;
//# sourceMappingURL=edgeWrapperUtils.js.map
