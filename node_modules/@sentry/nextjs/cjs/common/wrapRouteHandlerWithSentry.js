Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const utils = require('@sentry/utils');
const nextNavigationErrorUtils = require('./nextNavigationErrorUtils.js');
const platformSupportsStreaming = require('./utils/platformSupportsStreaming.js');
const responseEnd = require('./utils/responseEnd.js');
const tracingUtils = require('./utils/tracingUtils.js');

/**
 * Wraps a Next.js route handler with performance and error instrumentation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function wrapRouteHandlerWithSentry(
  routeHandler,
  context,
) {
  const { method, parameterizedRoute, headers } = context;

  return new Proxy(routeHandler, {
    apply: (originalFunction, thisArg, args) => {
      return tracingUtils.escapeNextjsTracing(() => {
        const isolationScope = tracingUtils.commonObjectToIsolationScope(headers);

        const completeHeadersDict = headers ? utils.winterCGHeadersToDict(headers) : {};

        isolationScope.setSDKProcessingMetadata({
          request: {
            headers: completeHeadersDict,
          },
        });

        const incomingPropagationContext = utils.propagationContextFromHeaders(
          completeHeadersDict['sentry-trace'],
          completeHeadersDict['baggage'],
        );

        const propagationContext = tracingUtils.commonObjectToPropagationContext(headers, incomingPropagationContext);

        return core.withIsolationScope(isolationScope, () => {
          return core.withScope(async scope => {
            scope.setTransactionName(`${method} ${parameterizedRoute}`);
            scope.setPropagationContext(propagationContext);
            try {
              return core.startSpan(
                {
                  name: `${method} ${parameterizedRoute}`,
                  attributes: {
                    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
                    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
                    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs',
                  },
                  forceTransaction: true,
                },
                async span => {
                  const response = await core.handleCallbackErrors(
                    () => originalFunction.apply(thisArg, args),
                    error => {
                      // Next.js throws errors when calling `redirect()`. We don't wanna report these.
                      if (nextNavigationErrorUtils.isRedirectNavigationError(error)) {
                        // Don't do anything
                      } else if (nextNavigationErrorUtils.isNotFoundNavigationError(error) && span) {
                        span.setStatus({ code: core.SPAN_STATUS_ERROR, message: 'not_found' });
                      } else {
                        core.captureException(error, {
                          mechanism: {
                            handled: false,
                          },
                        });
                      }
                    },
                  );

                  try {
                    if (span && response.status) {
                      core.setHttpStatus(span, response.status);
                    }
                  } catch (e) {
                    // best effort - response may be undefined?
                  }

                  return response;
                },
              );
            } finally {
              if (!platformSupportsStreaming.platformSupportsStreaming() || process.env.NEXT_RUNTIME === 'edge') {
                // 1. Edge transport requires manual flushing
                // 2. Lambdas require manual flushing to prevent execution freeze before the event is sent
                await responseEnd.flushQueue();
              }
            }
          });
        });
      });
    },
  });
}

exports.wrapRouteHandlerWithSentry = wrapRouteHandlerWithSentry;
//# sourceMappingURL=wrapRouteHandlerWithSentry.js.map
