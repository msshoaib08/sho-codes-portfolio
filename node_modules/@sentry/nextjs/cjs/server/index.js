var {
  _optionalChain
} = require('@sentry/utils');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const node = require('@sentry/node');
const utils = require('@sentry/utils');
const debugBuild = require('../common/debug-build.js');
const devErrorSymbolicationEventProcessor = require('../common/devErrorSymbolicationEventProcessor.js');
const getVercelEnv = require('../common/getVercelEnv.js');
const isBuild = require('../common/utils/isBuild.js');
const distDirRewriteFramesIntegration = require('./distDirRewriteFramesIntegration.js');
const httpIntegration = require('./httpIntegration.js');
const _error = require('../common/_error.js');
const wrapGetStaticPropsWithSentry = require('../common/wrapGetStaticPropsWithSentry.js');
const wrapGetInitialPropsWithSentry = require('../common/wrapGetInitialPropsWithSentry.js');
const wrapAppGetInitialPropsWithSentry = require('../common/wrapAppGetInitialPropsWithSentry.js');
const wrapDocumentGetInitialPropsWithSentry = require('../common/wrapDocumentGetInitialPropsWithSentry.js');
const wrapErrorGetInitialPropsWithSentry = require('../common/wrapErrorGetInitialPropsWithSentry.js');
const wrapGetServerSidePropsWithSentry = require('../common/wrapGetServerSidePropsWithSentry.js');
const wrapServerComponentWithSentry = require('../common/wrapServerComponentWithSentry.js');
const wrapRouteHandlerWithSentry = require('../common/wrapRouteHandlerWithSentry.js');
const wrapApiHandlerWithSentryVercelCrons = require('../common/wrapApiHandlerWithSentryVercelCrons.js');
const wrapMiddlewareWithSentry = require('../common/wrapMiddlewareWithSentry.js');
const wrapPageComponentWithSentry = require('../common/wrapPageComponentWithSentry.js');
const wrapGenerationFunctionWithSentry = require('../common/wrapGenerationFunctionWithSentry.js');
const withServerActionInstrumentation = require('../common/withServerActionInstrumentation.js');
const wrapApiHandlerWithSentry = require('../common/wrapApiHandlerWithSentry.js');

const globalWithInjectedValues = utils.GLOBAL_OBJ

;

// https://github.com/lforst/nextjs-fork/blob/9051bc44d969a6e0ab65a955a2fc0af522a83911/packages/next/src/server/lib/trace/constants.ts#L11
const NEXTJS_SPAN_NAME_PREFIXES = [
  'BaseServer.',
  'LoadComponents.',
  'NextServer.',
  'createServer.',
  'startServer.',
  'NextNodeServer.',
  'Render.',
  'AppRender.',
  'Router.',
  'Node.',
  'AppRouteRouteHandlers.',
  'ResolveMetadata.',
];

/**
 * A passthrough error boundary for the server that doesn't depend on any react. Error boundaries don't catch SSR errors
 * so they should simply be a passthrough.
 */
const ErrorBoundary = (props) => {
  if (!props.children) {
    return null;
  }

  if (typeof props.children === 'function') {
    return (props.children )();
  }

  // since Next.js >= 10 requires React ^16.6.0 we are allowed to return children like this here
  return props.children ;
};

/**
 * A passthrough redux enhancer for the server that doesn't depend on anything from the `@sentry/react` package.
 */
function createReduxEnhancer() {
  return (createStore) => createStore;
}

/**
 * A passthrough error boundary wrapper for the server that doesn't depend on any react. Error boundaries don't catch
 * SSR errors so they should simply be a passthrough.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function withErrorBoundary(
  WrappedComponent,
) {
  return WrappedComponent ;
}

/**
 * Just a passthrough since we're on the server and showing the report dialog on the server doesn't make any sense.
 */
function showReportDialog() {
  return;
}

/** Inits the Sentry NextJS SDK on node. */
function init(options) {
  if (isBuild.isBuild()) {
    return;
  }

  const customDefaultIntegrations = [
    ...node.getDefaultIntegrations(options).filter(
      integration =>
        // Next.js comes with its own Http instrumentation for OTel which would lead to double spans for route handler requests
        integration.name !== 'Http',
    ),
    httpIntegration.httpIntegration(),
  ];

  // Turn off Next.js' own fetch instrumentation
  // https://github.com/lforst/nextjs-fork/blob/1994fd186defda77ad971c36dc3163db263c993f/packages/next/src/server/lib/patch-fetch.ts#L245
  process.env.NEXT_OTEL_FETCH_DISABLED = '1';

  // This value is injected at build time, based on the output directory specified in the build config. Though a default
  // is set there, we set it here as well, just in case something has gone wrong with the injection.
  const distDirName = globalWithInjectedValues.__rewriteFramesDistDir__;
  if (distDirName) {
    customDefaultIntegrations.push(distDirRewriteFramesIntegration.distDirRewriteFramesIntegration({ distDirName }));
  }

  const opts = {
    environment: process.env.SENTRY_ENVIRONMENT || getVercelEnv.getVercelEnv(false) || process.env.NODE_ENV,
    defaultIntegrations: customDefaultIntegrations,
    ...options,
    // Right now we only capture frontend sessions for Next.js
    autoSessionTracking: false,
  };

  if (debugBuild.DEBUG_BUILD && opts.debug) {
    utils.logger.enable();
  }

  debugBuild.DEBUG_BUILD && utils.logger.log('Initializing SDK...');

  if (sdkAlreadyInitialized()) {
    debugBuild.DEBUG_BUILD && utils.logger.log('SDK already initialized');
    return;
  }

  core.applySdkMetadata(opts, 'nextjs', ['nextjs', 'node']);

  node.init(opts);

  const client = core.getClient();
  _optionalChain([client, 'optionalAccess', _ => _.on, 'call', _2 => _2('beforeSampling', ({ spanAttributes, spanName, parentSampled, parentContext }, samplingDecision) => {
    // If we encounter a span emitted by Next.js, we do not want to sample it
    // The reason for this is that the data quality of the spans varies, it is different per version of Next,
    // and we need to keep our manual instrumentation around for the edge runtime anyhow.
    // BUT we only do this if we don't have a parent span with a sampling decision yet (or if the parent is remote)
    if (
      (spanAttributes['next.span_type'] || NEXTJS_SPAN_NAME_PREFIXES.some(prefix => spanName.startsWith(prefix))) &&
      (parentSampled === undefined || _optionalChain([parentContext, 'optionalAccess', _3 => _3.isRemote]))
    ) {
      samplingDecision.decision = false;
    }
  })]);

  core.addEventProcessor(
    Object.assign(
      (event => {
        if (event.type === 'transaction') {
          // Filter out transactions for static assets
          // This regex matches the default path to the static assets (`_next/static`) and could potentially filter out too many transactions.
          // We match `/_next/static/` anywhere in the transaction name because its location may change with the basePath setting.
          if (_optionalChain([event, 'access', _4 => _4.transaction, 'optionalAccess', _5 => _5.match, 'call', _6 => _6(/^GET (\/.*)?\/_next\/static\//)])) {
            return null;
          }

          // Filter out transactions for requests to the tunnel route
          if (
            globalWithInjectedValues.__sentryRewritesTunnelPath__ &&
            event.transaction === `POST ${globalWithInjectedValues.__sentryRewritesTunnelPath__}`
          ) {
            return null;
          }

          // Filter out requests to resolve source maps for stack frames in dev mode
          if (_optionalChain([event, 'access', _7 => _7.transaction, 'optionalAccess', _8 => _8.match, 'call', _9 => _9(/\/__nextjs_original-stack-frame/)])) {
            return null;
          }

          // Filter out /404 transactions for pages-router which seem to be created excessively
          if (event.transaction === '/404') {
            return null;
          }

          return event;
        } else {
          return event;
        }
      }) ,
      { id: 'NextLowQualityTransactionsFilter' },
    ),
  );

  if (process.env.NODE_ENV === 'development') {
    core.addEventProcessor(devErrorSymbolicationEventProcessor.devErrorSymbolicationEventProcessor);
  }

  debugBuild.DEBUG_BUILD && utils.logger.log('SDK successfully initialized');
}

function sdkAlreadyInitialized() {
  return !!core.getClient();
}

exports.httpIntegration = httpIntegration.httpIntegration;
exports.captureUnderscoreErrorException = _error.captureUnderscoreErrorException;
exports.wrapGetStaticPropsWithSentry = wrapGetStaticPropsWithSentry.wrapGetStaticPropsWithSentry;
exports.wrapGetInitialPropsWithSentry = wrapGetInitialPropsWithSentry.wrapGetInitialPropsWithSentry;
exports.wrapAppGetInitialPropsWithSentry = wrapAppGetInitialPropsWithSentry.wrapAppGetInitialPropsWithSentry;
exports.wrapDocumentGetInitialPropsWithSentry = wrapDocumentGetInitialPropsWithSentry.wrapDocumentGetInitialPropsWithSentry;
exports.wrapErrorGetInitialPropsWithSentry = wrapErrorGetInitialPropsWithSentry.wrapErrorGetInitialPropsWithSentry;
exports.wrapGetServerSidePropsWithSentry = wrapGetServerSidePropsWithSentry.wrapGetServerSidePropsWithSentry;
exports.wrapServerComponentWithSentry = wrapServerComponentWithSentry.wrapServerComponentWithSentry;
exports.wrapRouteHandlerWithSentry = wrapRouteHandlerWithSentry.wrapRouteHandlerWithSentry;
exports.wrapApiHandlerWithSentryVercelCrons = wrapApiHandlerWithSentryVercelCrons.wrapApiHandlerWithSentryVercelCrons;
exports.wrapMiddlewareWithSentry = wrapMiddlewareWithSentry.wrapMiddlewareWithSentry;
exports.wrapPageComponentWithSentry = wrapPageComponentWithSentry.wrapPageComponentWithSentry;
exports.wrapGenerationFunctionWithSentry = wrapGenerationFunctionWithSentry.wrapGenerationFunctionWithSentry;
exports.withServerActionInstrumentation = withServerActionInstrumentation.withServerActionInstrumentation;
exports.wrapApiHandlerWithSentry = wrapApiHandlerWithSentry.wrapApiHandlerWithSentry;
exports.ErrorBoundary = ErrorBoundary;
exports.createReduxEnhancer = createReduxEnhancer;
exports.init = init;
exports.showReportDialog = showReportDialog;
exports.withErrorBoundary = withErrorBoundary;
Object.prototype.hasOwnProperty.call(node, '__proto__') &&
  !Object.prototype.hasOwnProperty.call(exports, '__proto__') &&
  Object.defineProperty(exports, '__proto__', {
    enumerable: true,
    value: node['__proto__']
  });

Object.keys(node).forEach(k => {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = node[k];
});
//# sourceMappingURL=index.js.map
