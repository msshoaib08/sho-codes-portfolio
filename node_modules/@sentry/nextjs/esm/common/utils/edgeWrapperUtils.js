import { withIsolationScope, continueTrace, startSpan, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, handleCallbackErrors, captureException, setHttpStatus, SPAN_STATUS_OK } from '@sentry/core';
import { winterCGRequestToRequestData } from '@sentry/utils';
import { flushQueue } from './responseEnd.js';
import { escapeNextjsTracing, commonObjectToIsolationScope } from './tracingUtils.js';

/**
 * Wraps a function on the edge runtime with error and performance monitoring.
 */
function withEdgeWrapping(
  handler,
  options,
) {
  return async function ( ...args) {
    return escapeNextjsTracing(() => {
      const req = args[0];
      return withIsolationScope(commonObjectToIsolationScope(req), isolationScope => {
        let sentryTrace;
        let baggage;

        if (req instanceof Request) {
          sentryTrace = req.headers.get('sentry-trace') || '';
          baggage = req.headers.get('baggage');

          isolationScope.setSDKProcessingMetadata({
            request: winterCGRequestToRequestData(req),
          });
        }

        isolationScope.setTransactionName(options.spanDescription);

        return continueTrace(
          {
            sentryTrace,
            baggage,
          },
          () => {
            return startSpan(
              {
                name: options.spanDescription,
                op: options.spanOp,
                forceTransaction: true,
                attributes: {
                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.withEdgeWrapping',
                },
              },
              async span => {
                const handlerResult = await handleCallbackErrors(
                  () => handler.apply(this, args),
                  error => {
                    captureException(error, {
                      mechanism: {
                        type: 'instrument',
                        handled: false,
                        data: {
                          function: options.mechanismFunctionName,
                        },
                      },
                    });
                  },
                );

                if (handlerResult instanceof Response) {
                  setHttpStatus(span, handlerResult.status);
                } else {
                  span.setStatus({ code: SPAN_STATUS_OK });
                }

                return handlerResult;
              },
            ).finally(() => flushQueue());
          },
        );
      });
    });
  };
}

export { withEdgeWrapping };
//# sourceMappingURL=edgeWrapperUtils.js.map
