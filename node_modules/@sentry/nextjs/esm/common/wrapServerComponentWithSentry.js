import { _optionalChain } from '@sentry/utils';
import { getActiveSpan, withIsolationScope, withScope, startSpanManual, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, handleCallbackErrors, SPAN_STATUS_ERROR, SPAN_STATUS_OK, captureException } from '@sentry/core';
import { winterCGHeadersToDict, propagationContextFromHeaders, uuid4 } from '@sentry/utils';
import { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils.js';
import { flushQueue } from './utils/responseEnd.js';
import { escapeNextjsTracing, commonObjectToIsolationScope, commonObjectToPropagationContext } from './utils/tracingUtils.js';

/**
 * Wraps an `app` directory server component with Sentry error instrumentation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function wrapServerComponentWithSentry(
  appDirComponent,
  context,
) {
  const { componentRoute, componentType } = context;
  // Even though users may define server components as async functions, for the client bundles
  // Next.js will turn them into synchronous functions and it will transform any `await`s into instances of the `use`
  // hook. ðŸ¤¯
  return new Proxy(appDirComponent, {
    apply: (originalFunction, thisArg, args) => {
      const requestTraceId = _optionalChain([getActiveSpan, 'call', _ => _(), 'optionalAccess', _2 => _2.spanContext, 'call', _3 => _3(), 'access', _4 => _4.traceId]);
      return escapeNextjsTracing(() => {
        const isolationScope = commonObjectToIsolationScope(context.headers);

        const headersDict = context.headers ? winterCGHeadersToDict(context.headers) : undefined;

        isolationScope.setSDKProcessingMetadata({
          request: {
            headers: headersDict,
          },
        });

        return withIsolationScope(isolationScope, () => {
          return withScope(scope => {
            scope.setTransactionName(`${componentType} Server Component (${componentRoute})`);

            const propagationContext = commonObjectToPropagationContext(
              context.headers,
              _optionalChain([headersDict, 'optionalAccess', _5 => _5['sentry-trace']])
                ? propagationContextFromHeaders(headersDict['sentry-trace'], headersDict['baggage'])
                : {
                    traceId: requestTraceId || uuid4(),
                    spanId: uuid4().substring(16),
                  },
            );

            scope.setPropagationContext(propagationContext);
            return startSpanManual(
              {
                op: 'function.nextjs',
                name: `${componentType} Server Component (${componentRoute})`,
                forceTransaction: true,
                attributes: {
                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'component',
                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs',
                },
              },
              span => {
                return handleCallbackErrors(
                  () => originalFunction.apply(thisArg, args),
                  error => {
                    if (isNotFoundNavigationError(error)) {
                      // We don't want to report "not-found"s
                      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'not_found' });
                    } else if (isRedirectNavigationError(error)) {
                      // We don't want to report redirects
                      span.setStatus({ code: SPAN_STATUS_OK });
                    } else {
                      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });
                      captureException(error, {
                        mechanism: {
                          handled: false,
                        },
                      });
                    }
                  },
                  () => {
                    span.end();

                    // flushQueue should not throw
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    flushQueue();
                  },
                );
              },
            );
          });
        });
      });
    },
  });
}

export { wrapServerComponentWithSentry };
//# sourceMappingURL=wrapServerComponentWithSentry.js.map
