Object.defineProperty(exports, '__esModule', { value: true });

const api = require('@opentelemetry/api');
const resources = require('@opentelemetry/resources');
const sdkTraceBase = require('@opentelemetry/sdk-trace-base');
const semanticConventions = require('@opentelemetry/semantic-conventions');
const core = require('@sentry/core');
const opentelemetry = require('@sentry/opentelemetry');
const utils = require('@sentry/utils');
const contextManager = require('../otel/contextManager.js');

/**
 * Initialize OpenTelemetry for Node.
 */
function initOpenTelemetry(client) {
  if (client.getOptions().debug) {
    const otelLogger = new Proxy(utils.logger , {
      get(target, prop, receiver) {
        const actualProp = prop === 'verbose' ? 'debug' : prop;
        return Reflect.get(target, actualProp, receiver);
      },
    });

    api.diag.setLogger(otelLogger, api.DiagLogLevel.DEBUG);
  }

  opentelemetry.setupEventContextTrace(client);

  const provider = setupOtel(client);
  client.traceProvider = provider;
}

/** Just exported for tests. */
function setupOtel(client) {
  // Create and configure NodeTracerProvider
  const provider = new sdkTraceBase.BasicTracerProvider({
    sampler: new opentelemetry.SentrySampler(client),
    resource: new resources.Resource({
      [semanticConventions.SEMRESATTRS_SERVICE_NAME]: 'node',
      [semanticConventions.SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',
      [semanticConventions.SEMRESATTRS_SERVICE_VERSION]: core.SDK_VERSION,
    }),
    forceFlushTimeoutMillis: 500,
  });
  provider.addSpanProcessor(new opentelemetry.SentrySpanProcessor());

  // Initialize the provider
  provider.register({
    propagator: new opentelemetry.SentryPropagator(),
    contextManager: new contextManager.SentryContextManager(),
  });

  return provider;
}

exports.initOpenTelemetry = initOpenTelemetry;
exports.setupOtel = setupOtel;
//# sourceMappingURL=initOtel.js.map
