import { _optionalChain } from '@sentry/utils';
import { HttpInstrumentation } from '@opentelemetry/instrumentation-http';
import { addOpenTelemetryInstrumentation, getClient } from '@sentry/opentelemetry';
import { defineIntegration, isSentryRequestUrl, getCapturedScopesOnSpan, getIsolationScope, getCurrentScope, setCapturedScopesOnSpan, addBreadcrumb } from '@sentry/core';
import { stripUrlQueryAndFragment, parseUrl, getSanitizedUrlString } from '@sentry/utils';
import { setIsolationScope } from '../sdk/scope.js';
import { addOriginToSpan } from '../utils/addOriginToSpan.js';
import { getRequestUrl } from '../utils/getRequestUrl.js';

const _httpIntegration = ((options = {}) => {
  const _breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;
  const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;
  const _ignoreIncomingRequests = options.ignoreIncomingRequests;
  const _InstrumentationClass = options._instrumentation || HttpInstrumentation;

  return {
    name: 'Http',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new _InstrumentationClass({
          ignoreOutgoingRequestHook: request => {
            const url = getRequestUrl(request);

            if (!url) {
              return false;
            }

            if (isSentryRequestUrl(url, getClient())) {
              return true;
            }

            if (_ignoreOutgoingRequests && _ignoreOutgoingRequests(url)) {
              return true;
            }

            return false;
          },

          ignoreIncomingRequestHook: request => {
            const url = getRequestUrl(request);

            const method = _optionalChain([request, 'access', _ => _.method, 'optionalAccess', _2 => _2.toUpperCase, 'call', _3 => _3()]);
            // We do not capture OPTIONS/HEAD requests as transactions
            if (method === 'OPTIONS' || method === 'HEAD') {
              return true;
            }

            if (_ignoreIncomingRequests && _ignoreIncomingRequests(url)) {
              return true;
            }

            return false;
          },

          requireParentforOutgoingSpans: false,
          requireParentforIncomingSpans: false,
          requestHook: (span, req) => {
            addOriginToSpan(span, 'auto.http.otel.http');

            // both, incoming requests and "client" requests made within the app trigger the requestHook
            // we only want to isolate and further annotate incoming requests (IncomingMessage)
            if (_isClientRequest(req)) {
              return;
            }

            const scopes = getCapturedScopesOnSpan(span);

            const isolationScope = (scopes.isolationScope || getIsolationScope()).clone();
            const scope = scopes.scope || getCurrentScope();

            // Update the isolation scope, isolate this request
            isolationScope.setSDKProcessingMetadata({ request: req });

            const client = getClient();
            if (client && client.getOptions().autoSessionTracking) {
              isolationScope.setRequestSession({ status: 'ok' });
            }
            setIsolationScope(isolationScope);
            setCapturedScopesOnSpan(span, scope, isolationScope);

            // attempt to update the scope's `transactionName` based on the request URL
            // Ideally, framework instrumentations coming after the HttpInstrumentation
            // update the transactionName once we get a parameterized route.
            const httpMethod = (req.method || 'GET').toUpperCase();
            const httpTarget = stripUrlQueryAndFragment(req.url || '/');

            const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;

            isolationScope.setTransactionName(bestEffortTransactionName);
          },
          responseHook: () => {
            const client = getClient();
            if (client && client.getOptions().autoSessionTracking) {
              setImmediate(() => {
                client['_captureRequestSession']();
              });
            }
          },
          applyCustomAttributesOnSpan: (
            _span,
            request,
            response,
          ) => {
            if (_breadcrumbs) {
              _addRequestBreadcrumb(request, response);
            }
          },
        }),
      );
    },
  };
}) ;

/**
 * The http integration instruments Node's internal http and https modules.
 * It creates breadcrumbs and spans for outgoing HTTP requests which will be attached to the currently active span.
 */
const httpIntegration = defineIntegration(_httpIntegration);

/** Add a breadcrumb for outgoing requests. */
function _addRequestBreadcrumb(
  request,
  response,
) {
  // Only generate breadcrumbs for outgoing requests
  if (!_isClientRequest(request)) {
    return;
  }

  const data = getBreadcrumbData(request);
  addBreadcrumb(
    {
      category: 'http',
      data: {
        status_code: response.statusCode,
        ...data,
      },
      type: 'http',
    },
    {
      event: 'response',
      request,
      response,
    },
  );
}

function getBreadcrumbData(request) {
  try {
    // `request.host` does not contain the port, but the host header does
    const host = request.getHeader('host') || request.host;
    const url = new URL(request.path, `${request.protocol}//${host}`);
    const parsedUrl = parseUrl(url.toString());

    const data = {
      url: getSanitizedUrlString(parsedUrl),
      'http.method': request.method || 'GET',
    };

    if (parsedUrl.search) {
      data['http.query'] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data['http.fragment'] = parsedUrl.hash;
    }

    return data;
  } catch (e) {
    return {};
  }
}

/**
 * Determines if @param req is a ClientRequest, meaning the request was created within the express app
 * and it's an outgoing request.
 * Checking for properties instead of using `instanceOf` to avoid importing the request classes.
 */
function _isClientRequest(req) {
  return 'outputData' in req && 'outputSize' in req && !('client' in req) && !('statusCode' in req);
}

export { httpIntegration };
//# sourceMappingURL=http.js.map
